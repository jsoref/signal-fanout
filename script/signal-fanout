#!/bin/bash
set -e -o pipefail

# The signals we're trapping.
TRAP_SIGNALS=(SIGHUP SIGINT SIGQUIT SIGUSR1 SIGUSR2 SIGPIPE SIGTERM)

# The signal used to terminate processes.
KILL_SIGNAL=SIGTERM

if [[ "$1" == "--inner" ]]; then
  shift

  handler() {
    signal="$1"
    echo "$(date): signal-fanout received $signal, propagating signal to all processes in the session:"
    ps -o pid,sess,pgid,command -p $(pgrep -s0)

    # Propagate the signal to all processes in the session
    pkill "-$signal" -s0

    if [[ "$signal" == "SIGINT" ]]; then
      echo "$(date): waiting 20 seconds for processes to terminate gracefully"
      sleep 20
      echo "$(date): sending $KILL_SIGNAL to all processes in the session:"
      pkill "-$KILL_SIGNAL" -s0

      echo "$(date): waiting 5 seconds before force killing processes"
      sleep 5
      echo "$(date): sending SIGKILL to all processes in the session:"
      pkill -9 -s0
    fi
  }

  trap_handler() {
    # Set a lock to prevent multiple invocations
    if [[ -n "${HANDLER_LOCK:-}" ]]; then
      return
    fi
    HANDLER_LOCK=1
    handler "$@"
  }

  for signal in "${TRAP_SIGNALS[@]}"; do
    # shellcheck disable=SC2064
    trap "trap_handler $signal" "$signal"
  done

  if [[ -x "$1" ]]; then
    # Full executable name is passed, e.g. "signal-fanout /bin/zsh {0}".
    "$@" &
  elif [[ ! -f "$1" ]] && which "$1" &>/dev/null; then
    # Shell name is passed, e.g. "signal-fanout zsh {0}".
    "$@" &
  else
    # Just a script file name is passed, e.g. "signal-fanout {0}".
    bash "$@" &
  fi

  wait

  # Wait for all child processes to finish before exiting
  while kill -0 $(pgrep -s0) 2>/dev/null; do
    sleep 1
  done

else
  if [[ "$1" == "" ]]; then
    echo "Usage examples:"
    echo "  - signal-fanout script-path"
    echo "  - signal-fanout zsh script-path"
    exit 1
  fi
  exec setsid --wait "${BASH_SOURCE[0]}" --inner "$@"
fi
