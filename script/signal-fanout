#!/bin/bash
set -e -o pipefail

# The signals we're trapping.
TRAP_SIGNALS=(SIGHUP SIGINT SIGQUIT SIGUSR1 SIGUSR2 SIGPIPE SIGTERM)

# The signal used to terminate processes.
KILL_SIGNAL=SIGTERM

if [[ "$1" == "--inner" ]]; then
  shift

  handler() {
    signal="$1"
    echo "$(date): signal-fanout received $signal, propagating signal to all processes in the session:"
    ps -o pid,sess,pgid,command -p $(pgrep -s0)
    pkill "-$signal" -s0

    if [[ "$signal" == "SIGINT" ]]; then
      # Give processes time to terminate gracefully
      sleep 7.5
      echo "$(date): sending $KILL_SIGNAL to all processes in the session:"
      pkill "-$KILL_SIGNAL" -s0

      # Wait a bit more before force killing
      sleep 2.5
      echo "$(date): sending SIGKILL to all processes in the session:"
      pkill -9 -s0
    fi
  }

  for signal in "${TRAP_SIGNALS[@]}"; do
    # shellcheck disable=SC2064
    trap "handler $signal" "$signal"
  done

  if [[ -x "$1" ]]; then
    # Full executable name is passed, e.g. "signal-fanout /bin/zsh {0}".
    "$@" & wait $!
  elif [[ ! -f "$1" ]] && which "$1" &>/dev/null; then
    # Shell name is passed, e.g. "signal-fanout zsh {0}".
    "$@" & wait $!
  else
    # Just a script file name is passed, e.g. "signal-fanout {0}".
    bash "$@" & wait $!
  fi

  # Wait for all child processes to finish before exiting
  while kill -0 $(pgrep -s0) 2>/dev/null; do
    sleep 1
  done

else
  if [[ "$1" == "" ]]; then
    echo "Usage examples:"
    echo "  - signal-fanout script-path"
    echo "  - signal-fanout zsh script-path"
    exit 1
  fi
  exec setsid --wait "${BASH_SOURCE[0]}" --inner "$@"
fi
